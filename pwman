#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
# Simple password manager
# Copyright (c) 2011-2019 Michael Buesch <m@bues.ch>
# Licensed under the GNU/GPL version 2 or later.
"""

import argparse
import importlib
import libpwman
import pathlib
import sys
import traceback

def getPassphrase(dbPath, interactiveMode):
	dbExists = dbPath.exists()
	if interactiveMode:
		if dbExists:
			print("Opening database '%s'..." % dbPath)
		else:
			print("Creating NEW database '%s'..." % dbPath)
	passphrase = libpwman.util.readPassphrase("Master passphrase",
						  verify=not dbExists)
	return passphrase

def run_script(dbPath, pyModName):
	try:
		if pyModName.lower().endswith(".py"):
			pyModName = pyModName[:-3]
		pyMod = importlib.import_module(pyModName)
	except ImportError as e:
		print("Failed to import --call-pymod "
		      "Python module '%s':\n%s" % (
		      pyModName, str(e)),
		      file=sys.stderr)
		return 1
	run = getattr(pyMod, "run", None)
	if not callable(run):
		print("%s.run is not a callable." % (
		      pyModName),
		      file=sys.stderr)
		return 1

	passphrase = getPassphrase(dbPath, interactiveMode=False)
	if passphrase is None:
		return 1
	db = libpwman.database.PWManDatabase(filename=dbPath,
					     passphrase=passphrase)
	try:
		run(db)
	except Exception as e:
		print("%s.run(database) raised an exception:\n\n%s" % (
		      pyModName, traceback.format_exc()),
		      file=sys.stderr)
		return 1
	db.flunkDirty()
	return 0

def run_ui(dbPath, commitClearsUndo, timeout, commands):
	passphrase = getPassphrase(dbPath, interactiveMode=not commands)
	if passphrase is None:
		return 1
	p = libpwman.PWMan(filename=dbPath,
			   passphrase=passphrase,
			   commitClearsUndo=commitClearsUndo,
			   timeout=timeout)
	if commands:
		for command in commands:
			p.runOneCommand(command)
	else:
		p.interactive()
	p.flunkDirty()
	return 0

def main():
	p = argparse.ArgumentParser()
	p.add_argument("commands", nargs="*", metavar="COMMAND",
		       help="Run this command. Starts in interactive mode, if no COMMAND is given.")
	p.add_argument("-d", "--database", type=str, default=None, metavar="PATH",
		       help="Use PATH as database file. If not given, %s is used." % (
			    libpwman.database.getDefaultDatabase()))
	p.add_argument("-U", "--commit-clear-undo", action="store_true",
		       help="The commit command clears undo queue.")
	p.add_argument("-t", "--timeout", type=int, default=600, metavar="SECONDS",
		       help="Sets the session timeout in seconds. Default is 10 minutes.")
	p.add_argument("-p", "--call-pymod", type=str, metavar="PYTHONSCRIPT.py",
		       help="Calls the Python function run(database) from Python module PYTHONSCRIPT. "
			    "An open PWManDatabase object is passed to run().")
	args = p.parse_args()

	dbPath = pathlib.Path(args.database) if args.database else None
	if not dbPath:
		dbPath = libpwman.database.getDefaultDatabase()
	if not dbPath:
		print("No database file specified", file=sys.stderr)
		return 1

	exitcode = 1
	try:
		if args.call_pymod:
			exitcode = run_script(dbPath=dbPath,
					      pyModName=args.call_pymod)
		else:
			exitcode = run_ui(dbPath=dbPath,
					  commitClearsUndo=args.commit_clear_undo,
					  timeout=args.timeout,
					  commands=args.commands)
	except (libpwman.database.CSQLError) as e:
		print("SQL error: " + str(e), file=sys.stderr)
		return 1
	except (libpwman.PWManError) as e:
		print("Error: " + str(e), file=sys.stderr)
		return 1
	except (libpwman.PWManTimeout) as e:
		libpwman.util.clearScreen()
		print("pwman session timeout after %d seconds of inactivity." % (
		      e.seconds), file=sys.stderr)
		p.flunkDirty()
		print("exiting...", file=sys.stderr)
		return 1
	return exitcode

if __name__ == "__main__":
	sys.exit(main())
